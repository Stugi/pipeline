package main

import (
	"bufio"
	"fmt"
	"os"
	"strconv"
	"sync"
	"time"
)

//Напишите код, реализующий пайплайн, работающий с целыми числами и состоящий из следующих стадий:

//1 //Напишите код, реализующий пайплайн, работающий с целыми числами и состоящий из следующих стадий:

//1 Стадия фильтрации отрицательных чисел (не пропускать отрицательные числа).
//2 Стадия фильтрации чисел, не кратных 3 (не пропускать такие числа), исключая также и 0.
//3 Стадия буферизации данных в кольцевом буфере с интерфейсом,
// 	соответствующим тому, который был дан в качестве задания в 19 модуле.
// 	В этой стадии предусмотреть опустошение буфера
// 	(и соответственно, передачу этих данных, если они есть, дальше) с определённым интервалом во времени.
// 	Значения размера буфера и этого интервала времени сделать настраиваемыми
// 	(как мы делали: через константы или глобальные переменные).

//Написать источник данных для конвейера. Непосредственным источником данных должна быть консоль.

//Также написать код потребителя данных конвейера. Данные от конвейера можно направить снова в консоль построчно, сопроводив их каким-нибудь поясняющим текстом, например: «Получены данные …».

//При написании источника данных подумайте о фильтрации нечисловых данных, которые можно ввести через консоль. Как и где их фильтровать, решайте сами.

//2 Стадия фильтрации чисел, не кратных 3 (не пропускать такие числа), исключая также и 0.
//3 Стадия буферизации данных в кольцевом буфере с интерфейсом,
// 	соответствующим тому, который был дан в качестве задания в 19 модуле.
// 	В этой стадии предусмотреть опустошение буфера
// 	(и соответственно, передачу этих данных, если они есть, дальше) с определённым интервалом во времени.
// 	Значения размера буфера и этого интервала времени сделать настраиваемыми
// 	(как мы делали: через константы или глобальные переменные).

//Написать источник данных для конвейера. Непосредственным источником данных должна быть консоль.

//Также написать код потребителя данных конвейера. Данные от конвейера можно направить снова в консоль построчно, сопроводив их каким-нибудь поясняющим текстом, например: «Получены данные …».

//При написании источника данных подумайте о фильтрации нечисловых данных, которые можно ввести через консоль. Как и где их фильтровать, решайте сами.

//Готовый код присылайте на проверку ментором в поле ниже. Если совсем не понимаете, с чего начать и как решать задачу,
//загляните в следующий юнит, а потом возвращайтесь со своим решением, чтобы отправить его ментору.

const bufferSize = 10
const flushInterval = 1 * time.Second

// фильтрации отрицательных чисел (не пропускать отрицательные числа)
func filterNegative(num int) bool {
	return num >= 0
}

// фильтрации чисел кратных 3 (не пропускать такие числа)
func filterMultiplesOf3(num int) bool {
	return num%3 != 0 && num != 0
}

// Структура кольцевого буфера
type BufferRing struct {
	data  []int
	head  int
	tail  int
	count int
	mu    sync.Mutex
}

// Конструктор кольцевого буфера
func NewBufferRing(size int) *BufferRing {
	return &BufferRing{
		data:  make([]int, size),
		head:  0,
		tail:  0,
		count: 0,
		mu:    sync.Mutex{},
	}
}

// Добавление элемента в кольцевой буфер
func (b *BufferRing) Push(v int) {
	b.mu.Lock()
	defer b.mu.Unlock()
	if b.count < len(b.data) {
		b.data[b.head] = v
		b.head = (b.head + 1) % len(b.data)
		b.count++
	}
}

// Получение элементов из кольцевого буфера
func (b *BufferRing) Get() []int {
	b.mu.Lock()
	defer b.mu.Unlock()
	data := make([]int, b.count)
	for i := 0; i < b.count; i++ {
		data[i] = b.data[(b.tail+i)%len(b.data)]
	}
	b.tail = (b.tail + b.count) % len(b.data)
	b.count = 0
	return data
}

// Источник данных для конвейера
func dataSource() chan int {
	ch := make(chan int)
	go func() {
		scanner := bufio.NewScanner(os.Stdin)
		for scanner.Scan() {
			text := scanner.Text()
			num, err := strconv.Atoi(text)
			if err != nil {
				fmt.Println("Ошибка ввода. Повторите попытку.")
				continue
			}
			ch <- num
		}
		close(ch)
	}()
	return ch
}

// Потребитель данных конвейера
func dataConsumer(ch chan int, buffer *BufferRing) {
	ticker := time.NewTicker(flushInterval)
	defer ticker.Stop()
	for {
		select {
		case num, ok := <-ch:
			if !ok {
				return
			}
			if filterNegative(num) && filterMultiplesOf3(num) {
				buffer.Push(num)
			}
		case <-ticker.C:
			data := buffer.Get()
			for _, num := range data {
				fmt.Printf("Получены данные: %d\n", num)
			}
		}
	}
}

func main() {
	buffer := NewBufferRing(bufferSize)
	ch := dataSource()
	dataConsumer(ch, buffer)
}
