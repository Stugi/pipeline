package main

import (
	"bufio"
	"log"
	"os"
	"strconv"
	"sync"
	"time"
)

//Напишите код, реализующий пайплайн, работающий с целыми числами и состоящий из следующих стадий:

//1 //Напишите код, реализующий пайплайн, работающий с целыми числами и состоящий из следующих стадий:

//1 Стадия фильтрации отрицательных чисел (не пропускать отрицательные числа).
//2 Стадия фильтрации чисел, не кратных 3 (не пропускать такие числа), исключая также и 0.
//3 Стадия буферизации данных в кольцевом буфере с интерфейсом,
// 	соответствующим тому, который был дан в качестве задания в 19 модуле.
// 	В этой стадии предусмотреть опустошение буфера
// 	(и соответственно, передачу этих данных, если они есть, дальше) с определённым интервалом во времени.
// 	Значения размера буфера и этого интервала времени сделать настраиваемыми
// 	(как мы делали: через константы или глобальные переменные).

//Написать источник данных для конвейера. Непосредственным источником данных должна быть консоль.

//Также написать код потребителя данных конвейера. Данные от конвейера можно направить снова в консоль построчно, сопроводив их каким-нибудь поясняющим текстом, например: «Получены данные …».

//При написании источника данных подумайте о фильтрации нечисловых данных, которые можно ввести через консоль. Как и где их фильтровать, решайте сами.

//2 Стадия фильтрации чисел, не кратных 3 (не пропускать такие числа), исключая также и 0.
//3 Стадия буферизации данных в кольцевом буфере с интерфейсом,
// 	соответствующим тому, который был дан в качестве задания в 19 модуле.
// 	В этой стадии предусмотреть опустошение буфера
// 	(и соответственно, передачу этих данных, если они есть, дальше) с определённым интервалом во времени.
// 	Значения размера буфера и этого интервала времени сделать настраиваемыми
// 	(как мы делали: через константы или глобальные переменные).

//Написать источник данных для конвейера. Непосредственным источником данных должна быть консоль.

//Также написать код потребителя данных конвейера. Данные от конвейера можно направить снова в консоль построчно, сопроводив их каким-нибудь поясняющим текстом, например: «Получены данные …».

//При написании источника данных подумайте о фильтрации нечисловых данных, которые можно ввести через консоль. Как и где их фильтровать, решайте сами.

//Готовый код присылайте на проверку ментором в поле ниже. Если совсем не понимаете, с чего начать и как решать задачу,
//загляните в следующий юнит, а потом возвращайтесь со своим решением, чтобы отправить его ментору.

// Задание такое: измените код так, чтобы каждое действие в программе пайплайна
// (включая каждую его стадию) добавлялось в журнал логов (проще говоря, в логи).
// В качестве потока, в который нужно направлять эти логи, выберите консоль.

const bufferSize = 10
const flushInterval = 1 * time.Second

var logger = log.New(os.Stdout, "", log.LstdFlags)

// фильтрации отрицательных чисел (не пропускать отрицательные числа)
func filterNegative(num int) bool {
	logger.Printf("Проверка числа на отрицательность: %d\n", num)
	return num >= 0
}

// фильтрации чисел кратных 3 (не пропускать такие числа)
func filterMultiplesOf3(num int) bool {
	logger.Printf("Проверка числа на кратность 3: %d\n", num)
	return num%3 != 0 && num != 0
}

// Структура кольцевого буфера
type BufferRing struct {
	data  []int
	head  int
	tail  int
	count int
	mu    sync.Mutex
}

// Конструктор кольцевого буфера
func NewBufferRing(size int) *BufferRing {
	logger.Printf("Инициализация буфера с размером %d\n", size)
	return &BufferRing{
		data:  make([]int, size),
		head:  0,
		tail:  0,
		count: 0,
		mu:    sync.Mutex{},
	}
}

// Добавление элемента в кольцевой буфер
func (b *BufferRing) Push(v int) {
	logger.Printf("Добавление числа в буфер: %d\n", v)
	b.mu.Lock()
	defer b.mu.Unlock()
	if b.count < len(b.data) {
		b.data[b.head] = v
		b.head = (b.head + 1) % len(b.data)
		b.count++
	}
}

// Получение элементов из кольцевого буфера
func (b *BufferRing) Get() []int {
	logger.Printf("Получение данных из буфера\n")
	b.mu.Lock()
	defer b.mu.Unlock()
	data := make([]int, b.count)
	for i := 0; i < b.count; i++ {
		data[i] = b.data[(b.tail+i)%len(b.data)]
	}
	b.tail = (b.tail + b.count) % len(b.data)
	b.count = 0
	return data
}

// Источник данных для конвейера
func dataSource() chan int {
	logger.Printf("Инициализация источника данных\n")
	ch := make(chan int)
	go func() {
		scanner := bufio.NewScanner(os.Stdin)
		for scanner.Scan() {
			text := scanner.Text()
			num, err := strconv.Atoi(text)
			if err != nil {
				logger.Printf("Некорректное значение: %s\n", text)
				continue
			}
			ch <- num
		}
		close(ch)
	}()
	return ch
}

// Потребитель данных конвейера
func dataConsumer(ch chan int, buffer *BufferRing) {
	logger.Printf("Инициализация потребителя данных\n")
	ticker := time.NewTicker(flushInterval)
	defer ticker.Stop()
	for {
		select {
		case num, ok := <-ch:
			if !ok {
				logger.Printf("Источник данных закрыт\n")
				return
			}
			logger.Printf("Получено значение: %d\n", num)
			if filterNegative(num) && filterMultiplesOf3(num) {
				buffer.Push(num)
			}
		case <-ticker.C:
			data := buffer.Get()
			for _, num := range data {
				logger.Printf("Получены данные: %d\n", num)
			}
		}
	}
}

func main() {
	logger.Printf("Инициализация пайплайна\n")
	buffer := NewBufferRing(bufferSize)
	ch := dataSource()
	dataConsumer(ch, buffer)
}
